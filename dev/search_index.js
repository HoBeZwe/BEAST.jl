var documenterSearchIndex = {"docs":
[{"location":"quadstrat/#Quadrature-strategies","page":"Quadrature strategies","title":"Quadrature strategies","text":"","category":"section"},{"location":"quadstrat/#Introduction","page":"Quadrature strategies","title":"Introduction","text":"","category":"section"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"There are many ways to approximately compute the singular integrals that appear in boundary element discretisations of surface and volume integral euqations.","category":"page"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"BEAST.jl is configured to select reasonable defaults, but advanced users may want to select their own quadrature rules. This section provides information on how to do this.","category":"page"},{"location":"quadstrat/#quaddata-and-quadrule","page":"Quadrature strategies","title":"quaddata and quadrule","text":"","category":"section"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"Numerical quadrature is governed by a pair of functions that need to be designed to work together:","category":"page"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"quaddata: this function is executed before the assembly loop is entered. It's job is to compute all data needed for quadrature that the developer wants to be cached. Typically this is all geometric information such as the parametric and cartesian coordinates of all quadratures rules for all elemenents. It makes sense to cache this data as it will be used many times over in the double for loop that governs assembly. Typically, near singular interactions require more careful treatment than far interactions. This means that multiple quadrature rules per elements can be required. In such cases, the developer may want to opt to sture quadrature points and weights for all these rules. The function returns a quaddata object that holds all the cached data.\nquadrule: quadrule is executed inside the assembly hotloop. It receives a pair of elements and the quaddata object as its arguments. Based on this, the relevant cached data is extracted and stored in a quadrule object. The type of this object will determine the actual quadrature routined that will be called upon to do the numerical quadrature.","category":"page"},{"location":"quadstrat/#quadstrat","page":"Quadrature strategies","title":"quadstrat","text":"","category":"section"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"The pair of quaddata and quadrule methods that is used is determined by the type of the operator and finite elements, and a quadstrat object. This object is passed to the assembly routine and passed on to quaddata and quadstrat, so it can be considered during dispatch.","category":"page"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"Parameters, such as those that determine the accuracy of the numerical quadrature, are part of the runtime payload of the quadstrat object. This is usefull when the user is interested on the impact of these parameters on the performance and the accuracy of the solver without having to supply a new pair of quadstrat/quaddata methods for each possible value of these parameters.","category":"page"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"Roughly this leads to the following (simplified) assembly routine:","category":"page"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"function assemble(op, tfs, bfs, store; quadstrat=QS)\n\n    tad, tels = assemblydata(op, tfs)\n    bad, bels = assemblydata(op, bfs)\n    \n    qd = quadata(op,tels,bels,quadstrat)\n    for tel in tels\n        for bel in bels\n            qr = quadrule(op,tel,bel,qd,quadstrat)\n            zlocal = momintegrals(op,tel,bel,qr)\n\n            for i in axes(zlocal,1)\n                for j in axes(zlocal,2)\n                    m, a = tad[tel,i]\n                    n, b = bad[bel,j]\n                    store(a*zlocal[i,j]*b,m,n)\nend end end end end","category":"page"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"It is conceivable that the types and functions described above look like this:","category":"page"},{"location":"quadstrat/","page":"Quadrature strategies","title":"Quadrature strategies","text":"struct DoubleNumQS\n    test_precision\n    trial_precision\nend\n\nfunction quaddata(op, tels, bels, quadstrat::DoubleNumQS)\n    tqps = [quadpoints(tel,precision=quadstrat.test_precision) for tel in tels]\n    bqps = [quadpoints(bel,precision=quadstrat.basis_precision) for bel in bels]\n    return (test_quadpoints=tqps, basis_quadpoints=bqps)\nend\n\n\nstruct DoubleNumQR\n    test_quadpoints\n    trial_quadpoints\nend\n\nstruct HighPrecisionQR end\n\nfunction quadrule(op, tel, bel, qd, quadstrat::DoubleNumQs)\n    if wellseparated(tel, bel)\n        return DoubleNumQR(qd.test_quadpoints[tel], qd.basis_quadpoints[bel])\n    else\n        return HighPrecisionQR(tel, bel)\n    end\nend\n\nfunction momintegrals(op, tel, bel, qr::DoubleNumQR)\n    ...\nend\n\nfunction momintegrals(op, tel, bel, qr::HighPrecisionQR)\n    ...\nend","category":"page"},{"location":"tdefie/#Solving-the-Time-Domain-EFIE-using-Marching-on-in-Time","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"","category":"section"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"If broadband information is required or if the system under study will be coupled to non-linear components, the scattering problem should be solved directly in the time domain, i.e. as a hyperbolic evolution problem.","category":"page"},{"location":"tdefie/#Building-the-geometry","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Building the geometry","text":"","category":"section"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"Building the geometry and defining the spatial finite elements happens in completely the same manner as for frequency domain simulations:","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"using CompScienceMeshes\nusing BEAST\nD, dx = 1.0, 0.3\nΓ = meshsphere(1.0, dx)\nX = raviartthomas(Γ)\nnothing # hide","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"Time domain currents are approximated in the tensor product of a spatial and temporal finite element space:","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"j(x) approx sum_i=1^N_T sum_m=1^N_S u_im T_i(t) f_m(x)","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"This package only supports translation invariant temopral basis functions, i.e.","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"T_i(t) = T(t - i Delta t)","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"where Delta t is the time step used to solve the problem. This time step depends on the bandwidth of the incident field and the desired accuracy. Space-Time Galerkin solvers of the type used here are not subject to stability conditions linking spatial and temporal discretisation resolutions.","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"We need a temporal trial space and test space. Common examples of temporal trial spaces are the shifted quadratic spline and shifted lagrange basis functions. In this example, a shifted quadratic spline S is used for the trial space, while a delta function U is used as the temporal test space to obtain a time-stepping solution.  ","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"Δt, Nt = 0.25, 300\nS = BEAST.timebasisspline2(Δt, Nt)\nU = BEAST.timebasisdelta(Δt, Nt)\nnothing # hide","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"We want to solve the EFIE, i.e. we want to find the current j such that","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"Tj = -e^i","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"where the incident electric field can be any Maxwell solution in the background medium. To describe this problem in Julia we create a retarded potential operator objects and a functional representing the incident field:","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"x = point(1.0,0.0,0.0)\ny = point(0.0,1.0,0.0)\nz = point(0.0,0.0,1.0)\ngaussian = BEAST.creategaussian(30Δt, 60Δt)\nE = BEAST.planewave(x, z, BEAST.derive(gaussian), 1.0)\nT = BEAST.MWSingleLayerTDIO(1.0,-1.0,-1.0,2,0)\nnothing; # hide","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"Using the finite element spaces defined above this retarded potential equation can be discretized.","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"V = X ⊗ S #Space and time trial basis\nW = X ⊗ U #Space and time test basis\n\nB = assemble(E, W)\nZ = assemble(T, W, V)\nnothing # hide","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"The variable Z can efficiently store the matrices corresponding to different delays (assemble knows about the specific sparsity pattern of such matrices and returns a sparse array of rank three fit for purpose).","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"The algorithm below solves the discrete convolution problem by marching on in time:","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"Z0 = Z[:,:,1]\nW0 = inv(Z0)\nx = BEAST.marchonintime(W0,Z,-B,Nt)\nnothing # hide","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"Computing the values of the induced current is now possible in the same manner as for frequency domain simulations by first converting our MOT solution back to the frequency domain using the fourier transform, along with some adjustments.","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"Xefie, Δω, ω0 = fouriertransform(x, Δt, 0.0, 2)\nω = collect(ω0 + (0:Nt-1)*Δω)\n_, i1 = findmin(abs(ω-1.0))\nω1 = ω[i1]\n\nue = Xefie[:,i1]\nue /= fouriertransform(gaussian)(ω1)\nfcr, geo = facecurrents(ue, X)\nnothing # hide","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"For now the package still relies upon Matlab for some of its visualisation. This dependency will be removed in the near future:","category":"page"},{"location":"tdefie/","page":"Solving the Time Domain EFIE using Marching-on-in-Time","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"include(Pkg.dir(\"CompScienceMeshes\",\"examples\",\"matlab_patches.jl\"))\nmat\"clf\"\npatch(geo, real.(norm.(fcr)))\nmat\"cd($(pwd()))\"\nmat\"print('current.png', '-dpng')\"","category":"page"},{"location":"assets/postproc/#Post-processing-and-Visualisation","page":"Post-processing and Visualisation","title":"Post-processing and Visualisation","text":"","category":"section"},{"location":"assets/postproc/#Field-computation","page":"Post-processing and Visualisation","title":"Field computation","text":"","category":"section"},{"location":"assets/postproc/","page":"Post-processing and Visualisation","title":"Post-processing and Visualisation","text":"The main API for the computation of fields in a vector of points is the potential function. This function is capable of computing","category":"page"},{"location":"assets/postproc/","page":"Post-processing and Visualisation","title":"Post-processing and Visualisation","text":"F(x) = int_Gamma K(xy) u(y) dy","category":"page"},{"location":"assets/postproc/","page":"Post-processing and Visualisation","title":"Post-processing and Visualisation","text":"with u(y) = Sigma_i=1^N u_i f_i(y) and K(xy) the integation kernel defining the type of potential. For example, the far field for a vector valued surface density is","category":"page"},{"location":"assets/postproc/","page":"Post-processing and Visualisation","title":"Post-processing and Visualisation","text":"F(x) = int_Gamma e^ik fracx cdot yx u(y) dy","category":"page"},{"location":"assets/postproc/","page":"Post-processing and Visualisation","title":"Post-processing and Visualisation","text":"For a far field potential such as this, the value only depends on the direction, not the magnitude, of x, as can be read off from the normalisation in the exponent.","category":"page"},{"location":"assets/postproc/","page":"Post-processing and Visualisation","title":"Post-processing and Visualisation","text":"The following script computes the far field along a semi-circle in the xz-plane.","category":"page"},{"location":"assets/postproc/","page":"Post-processing and Visualisation","title":"Post-processing and Visualisation","text":"Θ, Φ = range(0.0,stop=2π,length=100), 0.0\ndirs = [point(cos(ϕ)*sin(θ), sin(ϕ)*sin(θ), cos(θ)) for θ in Θ for ϕ in Φ]\nfarfield = potential(MWFarField3D(wavenumber=κ), dirs, u, X)","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"CurrentModule = BEAST","category":"page"},{"location":"#BEAST.jl-documentation","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"","category":"section"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"BEAST provides a number of types modelling concepts and a number of algorithms for the efficient and simple implementation of boundary and finite element solvers. It provides full implementations of these concepts for the LU based solution of boundary integral equations for the Maxwell and Helmholtz systems.","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"Because Julia only compiles code at execution time, users of this library can hook into the code provided in this package at any level. In the extreme case it suffices to provide overwrites of the assemble functions. In that case, only the LU solution will be performed by the code here.","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"At the other end it suffices that users only supply integration kernels that act on the element-element interaction level. This package will manage all required steps for matrix assembly.","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"For the Helmholtz 2D and Maxwell 3D systems, complete implementations are supplied. These models will be discussed in detail to give a more concrete idea of the APIs provides and how to extend them.","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"Central to the solution of boundary integral equations is the assembly of the system matrix. The system matrix is fully determined by specifying a kernel G, a set of trial functions, and a set of test functions.","category":"page"},{"location":"#Basis","page":"BEAST.jl documentation","title":"Basis","text":"","category":"section"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"Sets of both trial and testing functions are implemented by models following the basis concept. The term basis is somewhat misleading as it is nowhere required nor enforced that these functions are linearly independent. Models implementing the Basis concept need to comply to the following semantics.","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"numfunctions(basis): number of functions in the Basis.\ncoordtype(basis): type of (the components of) the values taken on by the functions in the Basis.\nscalartype(d): the scalar field underlying the vector space the basis functions take value in.\nrefspace(basis): returns the ReferenceSpace of local shape functions on which the Basis is built.\nassemblydata(basis): assemblydata returns an iterable collection elements of geometric elements and a look table ad for use in assembly of interaction matrices. In particular, for an index element_idx into elements and an index local_shape_idx in basis of local shape functions refspace(basis), ad[element_idx, local_shape_idx] returns the iterable collection of (global_idx, weight) tuples such that the local shape function at local_shape_idx defined on the element at element_idx contributes to the basis function at global_idx with a weight of weight.\ngeometry(basis): returns an iterable collection of Elements. The order in which these Elements are encountered corresponds to the indices used in the assembly data structure.","category":"page"},{"location":"#Reference-Space","page":"BEAST.jl documentation","title":"Reference Space","text":"","category":"section"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"The reference space concept defines an API for working with spaces of local shape functions. The main role of objects implementing this concept is to allow specialization of the functions that depend on the precise reference space used.","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"The functions that depend on the type and value of arguments modeling reference space are:","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"numfunctions(refspace, domain): returns the number of shape functions on each element.","category":"page"},{"location":"#Kernel","page":"BEAST.jl documentation","title":"Kernel","text":"","category":"section"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"A kernel is a fairly simple concept that mainly exists as part of the definition of a Discrete Operator. A kernel should obey the following semantics:","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"In many function definitions the kernel object is referenced by operator or something similar. This is a misleading name as an operator definition should always be accompanied by the domain and range space.","category":"page"},{"location":"#Discrete-Operator","page":"BEAST.jl documentation","title":"Discrete Operator","text":"","category":"section"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"Informally speaking, a Discrete Operator is a concept that allows for the computation of an interaction matrix. It is a kernel together with a test and trial basis. A Discrete Operator can be passed to assemble and friends to compute its matrix representation.","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"A discrete operator is a triple (kernel, test_basis, trial_basis), where kernel is a Kernel, and test_basis and trial_basis are Bases. In addition, the following expressions should be implemented and behave according to the correct semantics:","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"quaddata(operator,test_refspace,trial_refspace,test_elements,trial_elements): create the data required for the computation of element-element interactions during assembly of discrete operator matrices.\nquadrule(operator,test_refspace,trial_refspace,p,test_element,q_trial_element,qd): returns an integration strategy object that will be passed to momintegrals! to select an integration strategy. This rule can depend on the test/trial reference spaces and interacting elements. The indices p and q refer to the position of the interacting elements in the enumeration defined by geometry(basis) and allow for fast retrieval of any element specific data stored in the quadrature data object qd.\nmomintegrals!(operator,test_refspace,trial_refspace,test_element,trial_element,zlocal,qr): this function computes the local interaction matrix between the set of local test and trial shape functions and a specific pair of elements. The target matrix zlocal is provided as an argument to minimise memory allocations over subsequent calls. qr is an object returned by quadrule and contains all static and dynamic data defining the integration strategy used.","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"In the context of fast methods such as the Fast Multipole Method other algorithms on Discrete Operators will typically be defined to compute matrix vector products. These algorithms do not explicitly compute and store the interaction matrix (this would lead to unacceptable computational and memory complexity).","category":"page"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"elements","category":"page"},{"location":"#BEAST.elements","page":"BEAST.jl documentation","title":"BEAST.elements","text":"elements(geo)\n\nCreate an iterable collection of the elements stored in geo. The order in which this collection produces the elements determines the index used for lookup in the data structures returned by assemblydata and quaddata.\n\n\n\n\n\n","category":"function"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"numfunctions\ncoordtype\nscalartype\nassemblydata\ngeometry\nrefspace","category":"page"},{"location":"#BEAST.numfunctions","page":"BEAST.jl documentation","title":"BEAST.numfunctions","text":"numfunctions(basis)\n\nNumber of functions in the basis.\n\n\n\n\n\n","category":"function"},{"location":"#CompScienceMeshes.coordtype","page":"BEAST.jl documentation","title":"CompScienceMeshes.coordtype","text":"coordtype(mesh)\n\nReturns eltype(vertextype(mesh))\n\n\n\n\n\ncoordtype(simplex)\n\nReturn coordinate type used by simplex.\n\n\n\n\n\n","category":"function"},{"location":"#BEAST.scalartype","page":"BEAST.jl documentation","title":"BEAST.scalartype","text":"scalartype(x)\n\nThe scalar field over which the values of a global or local basis function, or an operator are defined. This should always be a scalar type, even if the basis or operator takes on values in a vector or tensor space. This data type is used to determine the eltype of assembled discrete operators.\n\n\n\n\n\n","category":"function"},{"location":"#BEAST.assemblydata","page":"BEAST.jl documentation","title":"BEAST.assemblydata","text":"charts, admap, act_to_global = assemblydata(basis; onlyactives=true)\n\nGiven a basis this function returns a data structure containing the information required for matrix assemble, that is, the vector charts containing Simplex elements, a variable admap of type AssemblyData, and a mapping from indices of actively used simplices to global simplices.\n\nWhen onlyactives is true, another layer of indices is introduced to filter out all cells of the mesh that are not in the union of the support of the basis functions (i.e., when the basis functions are defined only on a part of the mesh).\n\nadmap is, in essence, a three-dimensional array of named tuples, which, by wrapping it in the struct AssemblyData, allows the definition of iterators. The tuple consists of the two entries\n\nadmap[i,r,c].globalindex\nadmap[i,r,c].coefficient\n\nHere, c and r are indices in the iterable set of (active) simplices and the set of shape functions on each cell/simplex: r ranges from 1 to the number of shape functions on a cell/simplex, c ranges from 1 to the number of active simplices, and i ranges from 1 to the number of maximal number of basis functions, where any of the shape functions contributes to. \n\nFor example, for continuous piecewise linear lagrange functions (c0d1), each of the three shape functions on a triangle are associated with exactly one Lagrange function, and therefore i is limited to 1.\n\nNote: When onlyactives=false, the indices c correspond to the position of the corresponding cell/simplex whilst iterating over geometry(basis). When onlyactives=true, then act_to_global(c) correspond to the position of the corresponding cell/simplex whilst iterating over geometry(basis).\n\nFor a triplet (i,r,c), globalindex is the index in the basis of the ith basis function that has a contribution from shape function r on (active) cell/simplex c. coefficient is the coefficient of that contribution in the linear combination defining that basis function in terms of shape function.\n\n\n\n\n\n","category":"function"},{"location":"#BEAST.geometry","page":"BEAST.jl documentation","title":"BEAST.geometry","text":"geometry(basis)\n\nReturns an iterable collection of geometric elements on which the functions in basis are defined. The order the elements are encountered needs correspond to the element indices used in the data structure returned by assemblydata.\n\n\n\n\n\n","category":"function"},{"location":"#BEAST.refspace","page":"BEAST.jl documentation","title":"BEAST.refspace","text":"refspace(basis)\n\nReturns the ReferenceSpace of local shape functions on which the basis is built.\n\n\n\n\n\n","category":"function"},{"location":"","page":"BEAST.jl documentation","title":"BEAST.jl documentation","text":"quaddata\nquadrule\nmomintegrals!","category":"page"},{"location":"#BEAST.quaddata","page":"BEAST.jl documentation","title":"BEAST.quaddata","text":"quaddata(operator, test_refspace, trial_refspace, test_elements, trial_elements)\n\nReturns an object cashing data required for the computation of boundary element interactions. It is up to the client programmer to decide what (if any) data is cached. For double numberical quadrature, storing the integration points for example can significantly speed up matrix assembly.\n\noperator is an integration kernel.\ntest_refspace and trial_refspace are reference space objects. quadata\n\nis typically overloaded on the type of these local spaces of shape functions. (See the implementation in maxwell.jl for an example).\n\ntest_elements and trial_elements are iterable collections of the geometric\n\nelements on which the finite element space are defined. These are provided to allow computation of the actual integrations points - as opposed to only their coordinates.\n\n\n\n\n\n","category":"function"},{"location":"#BEAST.quadrule","page":"BEAST.jl documentation","title":"BEAST.quadrule","text":"quadrule(operator, test_refspace, trial_refspace, test_index, test_chart, trial_index, trial_chart, quad_data)\n\nBased on the operator kernel and the test and trial elements, this function builds an object whose type and data fields specify the quadrature rule that needs to be used to accurately compute the interaction integrals. The quad_data object created by quaddata is passed to allow reuse of any precomputed data such as quadrature points and weights, geometric quantities, etc.\n\nThe type of the returned quadrature rule will help in deciding which method of momintegrals to dispatch to.\n\n\n\n\n\n","category":"function"},{"location":"#BEAST.momintegrals!","page":"BEAST.jl documentation","title":"BEAST.momintegrals!","text":"momintegrals!(biop, tshs, bshs, tcell, bcell, interactions, strat)\n\nFunction for the computation of moment integrals using simple double quadrature.\n\n\n\n\n\n","category":"function"},{"location":"assemble/#The-Matrix-Assemble-Routine","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"","category":"section"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"A lot of the design of this package derives from the need to express boundary element and finite element matrix assembly in a concise but general manner that is compatible with a wide range of linear and bilinear forms as encountered in the solution of variational problems.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"In this section the matrix assembly routine at the center of this package will be discussed. As a case study we will go over the steps required to extend support for new kernels and new finite element spaces.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"The matrix assemble routine is surprisingly short:","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"function assemblechunk!(biop::IntegralOperator, tfs::Space, bfs::Space, store)\n\n    test_elements, tad = assemblydata(tfs)\n    bsis_elements, bad = assemblydata(bfs)\n\n    tshapes = refspace(tfs); num_tshapes = numfunctions(tshapes)\n    bshapes = refspace(bfs); num_bshapes = numfunctions(bshapes)\n\n    T = promote_type(scalartype(biop), scalartype(tfs), scalartype(bfs))\n    zlocal = zeros(T, num_tshapes, num_bshapes)\n\n    qd = quaddata(biop, tshapes, bshapes, test_elements, bsis_elements)\n    for (p,tcell) in enumerate(test_elements), (q,bcell) in enumerate(bsis_elements)\n\n        fill!(zlocal, 0)\n        strat = quadrule(biop, tshapes, bshapes, p, tcell, q, bcell, qd)\n        momintegrals!(biop, tshapes, bshapes, tcell, bcell, zlocal, strat)\n\n        for j in 1 : num_bshapes, i in 1 : num_tshapes\n            z = zlocal[i,j]\n            for (m,a) in tad[p,i], (n,b) in bad[q,j]\n                store(a*z*b, m, n)\nend end end end","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Support for direct product spaces, linear combinations of kernels, non-standard storage of matrix elements, and parallel execution is provided by layers on top of this assembly routine. In this section we will focus on discussing the design and implementation of this inner building block that lies at the basis of more general functionality.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Finite element spaces are usually stored as a collection of functions that in turn each comprise contributions from a limited number of geometric elements that make up the support of the function. In FEM and BEM matrix assembly, however, we need the tranposed information: given a geometric cell, and a local shape function, we need the ability to efficiently retrieve the list of basis functions whose definition contains the given local shape function on the given cell and the weight (aka coefficient) by which it contributes. The data structure that contains this information is referred to as the assembly data ad. In particular, ad[e,s], where e is the index of a geometric cell and s is the index of a local shape function, returns an iterable collection of pairs (m,w) where m is an index into the iterable collection of basis functions making up the finite element space and w is a weight, such that shape function s on geometric element e contributes with weight w to basis function n.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"test_elements, tad = assemblydata(tfs)\nbsis_elements, bad = assemblydata(bfs)","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"One final note on the assemblydata function: as you can see from the above snippet, the function returns, in addition to the actual assembly data, an iterable collection of geometric elements. This collection is a subset of the collection of elements making up the geometry on which the finite element space is defined. The elements returned are those that actually appear in the domain of one or more of the functions that span the finite element space. The double for loop that iterates over pairs of trial and testing functions will only visit those used elements. Elements that are part of the geometry but do not appear as part of the support of a function are skipped. This behaviour is required to guarantee scalability when using multiple threads in assembling the matrix: each thread is assigned a subset of the basis functions; visiting unused elements in all threads is harmful for the overall efficiency.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"With this assembly data in hand, matrix assembly can be done by iterating over geometric cells, rather than over basis functions. Doing this avoids visiting a given geometric cell more than once. When computing matrices resulting from discretisation with e.g. Raviart-Thomas elements, this can speed up assembly time with a factor 9.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"The problem of matrix assembly is now reduced to the computation of interactions between local shape functions defined on all possible pairs of geometric cells. The space of local shape functions can be retrieved by calling","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"tshapes = refspace(tfs); num_tshapes = numfunctions(tshapes)\nbshapes = refspace(bfs); num_bshapes = numfunctions(bshapes)","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Here, num_tshapes and num_bshapes are the number of local shape functions. For example, when using Raviart-Thomas elements, the number of local shape functions equals three (one for every edge of the reference triangle).","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Based on this dimension, and based on the types used to represent numbers in the fields over which the spaces and the kernel are defined, the storage for local shape function interaction is pre-allocated:","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"T = promote_type(scalartype(biop), scalartype(tfs), scalartype(bfs))\nzlocal = zeros(T, num_tshapes, num_bshapes)","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Note that the computation of the storage type ensures that high precision or complex data types are only used when required. At all times the minimal storage type is selected. Not only does this keep memory use down, it also results in faster linear algebra computations such as matrix-vector multiplication.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Before entering the double for loop that is responsible for the enumeration of all pairs of geometric cells (a trial cell pairs with a test cell), the implementer is given the opportunity to precompute data for use in the integration kernels. For example when using numerical quadrature rules to compute the double integral in the expression of the matrix entries, it is likely that a set of quadrature points for any given trial cells will be reused in interactions with a large number of test cells. To avoid computing these points and weights over and over, the client developer is given the opportunity to compute and store them by providing an appropriate method for quaddata . If memory use is more important the runtime, the client programmer is perfectly allowed to compute points and weights on the fly without storing them.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"fill!(zlocal, 0)\nstrat = quadrule(biop, tshapes, bshapes, p, tcell, q, bcell, qd)\nmomintegrals!(biop, tshapes, bshapes, tcell, bcell, zlocal, strat)","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"For a given pair (tcell,bcell) of test cell and trial cell (with respective indices p and q in collections test_elements and bsis_elements), all possible interactions between local shape functions are computed. After resetting the buffer used to store these interactions, the quadrature strategy is determined. The quadrature strategy in general could depend on:","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"the kernel biop defining the integral operator,\nthe local test and trial shape functions tshapes and bshapes (functions of high polynomial degree and functions that are highly oscillatory typically require bespoke integration methods),\nand the geometric test and trial cells tcell and bcell (cells that touch or are near to each other lead to quickly varying or even singular integrands requiring dedicated integration rules).","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"The method returns an object strat that: (i) describes (by its type and its data fields) the integration strategy that is appropriate to compute the current set of local interactions, (ii) contains all data precomputed and stored in qd that is relevant to this particular integration (for example a set of quadrature points and weights). This explains why the indices p and q where passed too quadrule: they allow for the quick retrieval of relevant pre-stored data from qd.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"The routing that is responsible for the actual computation of the interactions between the local shape functions takes the quadrule object strat as one of its arguments. The idea is that momintegrals! has many methods, not only for different types of kernel and shape functions, but also for different types of strat. For example, there are implementations of momintegrals! for the computation of the Maxwellian single layer operator w.r.t. spaces of Raviart-Thomas elements that employ double numerical quadrature, singularity extraction, and even more advanced integration routines.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Note: the type of strat depends on the orientation of the two interacting geometric cells. This information is only available at runtime. In other words, there will be a slight type instability at this point in the code. This is by design however, and not different from the use of virtual functions in an c++ implementation. Numerical experiments show that this form of runtime polymorphism results in negligible runtime overhead.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"When all possible interactions between local shape functions have been computed, they need to be stored in the global system matrix. This is done in the matrix assembly loop:","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"for j in 1 : num_bshapes\n    for i in 1 : num_tshapes\n        z = zlocal[i,j]\n        for (m,a) in tad[p,i]\n            for (n,b) in bad[q,j]\n                store(a*z*b, m, n)\n            end\n        end\n    end\nend","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"For both the test and trial local shape functions, the global indices at which they appear in the finite element space (and the corresponding weights) are retrieved from the assembly data objects. The contributing value v = a*z*b is constructed and its storage is delegated to the store method, which we received as one of the arguments passed to assemble_chunk!. In the simplest case, assemble_chunk! can be used like this:","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Z = zeros(ComplexF64, numfunctions(tfs), numfunctions(bfs))\nstore(v, m, n) = (Z[m,n] += v)\nassemble_chunk!(kernel, tfs, bfs, store)","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"In other words store will simply add the computed value to the specified entry in the global system matrix. Allowing the caller to specify store as an argument allows for more flexibility than hardcoding this behaviour in the assembly routine. Indeed, when computing blocks of a larger system, or when e.g. the transposed or a multiple of a given operator is desired, a fairly simple redefinition of store can provide this functionality. This is also the reason why assemble_chunk! ends in an exclamation mark: even though strictly speaking none of the arguments are modified, the function clearly has an effect on variables defined outside of its scope!","category":"page"},{"location":"assemble/#Case-Study:-Implementation-of-the-Nitsche-Operator-Assembly","page":"The Matrix Assemble Routine","title":"Case Study: Implementation of the Nitsche Operator Assembly","text":"","category":"section"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"In the Nitsche method for the Maxwell system, penalty terms are added to the classic discretisation of the EFIE. When discretized using a non-conforming finite elements space (typically because the underlying geometric mesh is not conforming), the penalty term will force the solution to be divergence conforming in some weak sense. The penalty term derives from the following bilinear form:","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"p(vu) = int_gamma v(x) int_Γ frace^-ikx-y4πx-y u(y) dy dx","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Note that u(x) is supported by a 2D surface Γ whereas v(y) is supported by a 1D curve γ. The complete implementation of this operator could look like","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"mutable struct SingleLayerTrace{T} <: MaxwellOperator3D\n    gamma::T\nend\n\nfunction quaddata(operator::SingleLayerTrace,\n    localtestbasis::LagrangeRefSpace,  localtrialbasis::LagrangeRefSpace,\n    testelements,  trialelements)\n\n  tqd = quadpoints(localtestbasis,  testelements,  (10,))\n  bqd = quadpoints(localtrialbasis, trialelements, (8,))\n\n  return (tpoints=tqd, bpoints=bqd)\nend\n\nfunction quadrule(op::SingleLayerTrace, g::LagrangeRefSpace, f::LagrangeRefSpace, i, τ, j, σ, qd)\n    DoubleQuadRule(\n        qd.tpoints[1,i],\n        qd.bpoints[1,j]\n    )\nend\n\nintegrand(op::SingleLayerTrace, kernel, g, τ, f, σ) = f[1]*g[1]*kernel.green","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Every kernel corresponds with a type. Kernels can potentially depend on a set of parameters; these appear as fields in the type. Here our Nitsche kernel depends on the wavenumber. In quaddata we precompute quadrature points for all geometric cells in the supports of test and trial elements. This is fairly sloppy: only one rule for test and trial integration is considered. A high accuracy implementation would typically compute points for both low quality and high quality quadrature rules.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Also quadrule is sloppy: we always select a DoubleQuadRule to perform the computation of interactions between local shape functions. No singularity extraction or other advanced technique is considered for nearby interactions. Clearly amateurs at work here!","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"BEAST provides a default implementation of an integration routine using double numerical quadrature. All that is required to tap into that implementation is a method overloading integrand. From the above formula it is clear what this method should look like.","category":"page"},{"location":"assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"That's it!","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"newcommandvt1boldsymbol1\nnewcommanduv1hatboldsymbol1\nnewcommandarr1mathsf1\nnewcommandmat1boldsymbolmathsf1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial we will go through the steps required for the formulation and the solution of the scattering of a time harmonic electromagnetic wave by a rectangular plate by means of the solution of the electric field integral equation.","category":"page"},{"location":"tutorial/#Building-the-geometry","page":"Tutorial","title":"Building the geometry","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The sibling package CompScienceMeshes provides data structures and algorithms for working with simplical meshes in computational science. We will use it to create the geometry:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CompScienceMeshes, BEAST\no, x, y, z = euclidianbasis(3)\n\nh = 0.2\nΓ = meshrectangle(1.0, 1.0, h)\n@show numvertices(Γ)\n@show numcells(Γ)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we create the finite element space of Raviart-Thomas aka Rao-Wilton-Glisson functions subordinate to the triangulation Γ constructed above:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"X = raviartthomas(Γ)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The scattering problem is defined by specifying the single layer operator and the functional acting as excitation. Here, the plate is illuminated by a plane wave. The actual excitation is the tangential trace of this electric field. This trace be constructed easily by using the symbolic normal vector field n defined as part of the BEAST package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"κ = 1.0\nE = Maxwell3D.planewave(direction=ẑ, polarization=x̂, wavenumber=κ)\ne = (n × E) × n\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The single layer potential is also predefined by the BEAST package:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"t = Maxwell3D.singlelayer(wavenumber=κ)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It corresponds to the bilinear form","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"t(vtkvtj) = frac1ik int_Gamma int_Gamma nabla cdot vtk(x) nabla cdot vtj(y) frace^-ikx-y4pix-y dy dx - ik int_Gamma int_Gamma vtk(x) cdot vtj(y) frace^-ikx-y4pix-y dy dx","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using the LinearForms package, which implements a simple form compiler for Julia (@varform), the EFIE can be defined and discretised by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@hilbertspace j\n@hilbertspace k\nefie = @discretise t[k,j]==e[k]  j∈X k∈X\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Solving and computing the values of the induced current in the centers of the triangles of the mesh is now straightforward:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"u = solve(efie)\nfcr, geo = facecurrents(u,X)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting current distribution can be visualised by e.g. Matlab, Paraview, Plotly,...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"}]
}
